use std::{collections::HashSet, fmt::Write, str};

use colored::Colorize;
use serde::{Deserialize, Serialize};

pub struct Generator {
    pub cube_count: usize,
    pub metadata: Option<Metadata>,
}

#[derive(Debug, Deserialize)]
pub struct Metadata {
    pub cubes: Vec<Cube>,
}

#[derive(Debug, Deserialize)]
pub struct Cube {
    pub name: String,
    pub dimensions: Option<Vec<FieldSet>>,
    pub measures: Option<Vec<FieldSet>>,
}

#[derive(Debug, Deserialize)]
pub struct Meta {
    pub extractable: Option<bool>,
}

#[derive(Debug, Deserialize)]
pub struct FieldSet {
    pub name: String,
    pub meta: Option<Meta>,
}

impl Generator {
    pub fn fetch_metadata(&mut self, cube_url: String) {
        let resp = match fetch_cube_metadata(&cube_url) {
            Ok(resp) => resp,
            Err(err) => {
                eprintln!("{} {}", "Error fetching cube metadata: ".red(), err);
                std::process::exit(0);
            }
        };

        self.cube_count = resp.cubes.len();
        self.metadata = Some(resp);
    }

    pub fn generate(&self, output_dir: String, file_name: String, skip_errors: bool) {
        let mut output: String = "".to_string();
        let mut all_dimension_types: Vec<String>;
        let mut all_measure_types: Vec<String>;

        let file_header =
            "// !! This file is generated by Cube Type Extractor RS - do not modify !!";
        let _ = output.write_str(file_header);

        let metadata = match &self.metadata {
            Some(m) => m,
            None => {
                eprintln!("{}", "Error: Metadata is missing".red());
                return;
            }
        };

        for cube in &metadata.cubes {
            // skip a cube that contains the word Error
            if !cube.name.contains("Error") {
                process_cube(cube);
            }
            continue;
        }
    }
}

fn process_cube(cube: &Cube) {
    let dimensions = match &cube.dimensions {
        Some(d) => d,
        None => {
            eprintln!("{}", "Error: No dimensions are defined".red());
            return;
        }
    };

    let measures = match &cube.measures {
        Some(m) => m,
        None => {
            eprintln!("{}", "Error: No measures are defined".red());
            return;
        }
    };

    let dimension_union = extract_to_union(dimensions);
    let measure_union = extract_to_union(measures);
    // println!(
    //     "{} dimensions == {}",
    //     cube.name.blue(),
    //     dimension_union.green()
    // );
    // println!("{} measures == {}", cube.name.blue(), measure_union.red());
}

fn extract_to_union(fields: &[FieldSet]) -> String {
    let mut items: Vec<String> = Vec::new();

    for field in fields {
        if let Some(true) = field.meta.as_ref().and_then(|meta| meta.extractable) {
            let field_name = extract_name(&field.name);
            items.push(field_name);
        }
    }

    join_union_fields(items)
}

#[tokio::main]
async fn fetch_cube_metadata(cube_url: &str) -> Result<Metadata, Box<dyn std::error::Error>> {
    let client = reqwest::Client::new();
    let url = format!("{}/v1/meta", cube_url);

    let body = client
        .get(&url)
        .send()
        .await?
        .error_for_status()? // check for http errors
        .text()
        .await?;

    let metadata: Metadata = serde_json::from_str(&body).map_err(|e| {
        eprintln!("Error decoding response: {}", e);
        e
    })?;

    Ok(metadata)
}

fn extract_name(full_name: &str) -> String {
    full_name.split('.').last().unwrap().to_string()
}

fn join_union_fields(items: Vec<String>) -> String {
    let unique_items: HashSet<String> = items.into_iter().collect();
    unique_items.into_iter().collect::<Vec<_>>().join(" | ")
}

fn capitalize(s: &str) -> String {
    let mut chars = s.chars();
    chars.next().map_or_else(String::new, |c| {
        c.to_uppercase().collect::<String>() + chars.as_str()
    })
}

fn contains_ignore_case(input: &str, sub_string: &str) -> bool {
    return input.to_lowercase().contains(&sub_string.to_lowercase());
}

fn skip(name: &str, check_case: &str) {
    if contains_ignore_case(name, check_case) {
        println!("{}", "Skipping cube due to ignore case match".yellow());
    }
}
