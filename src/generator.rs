use colored::Colorize;
use indicatif::{ProgressBar, ProgressStyle};
use serde::Deserialize;

use std::{borrow::Cow, collections::HashSet, str};

use crate::configuration;

pub struct Generator {
    pub cube_count: usize,
    pub metadata: Option<Metadata>,
}

#[derive(Debug, Deserialize)]
pub struct Metadata {
    pub cubes: Vec<Cube>,
}

#[derive(Debug, Deserialize)]
pub struct Cube {
    pub name: String,
    pub dimensions: Option<Vec<FieldSet>>,
    pub measures: Option<Vec<FieldSet>>,
}

#[derive(Debug, Deserialize)]
pub struct Meta {
    pub extractable: Option<bool>,
}

#[derive(Debug, Deserialize)]
pub struct FieldSet {
    pub name: String,
    pub meta: Option<Meta>,
}

impl Generator {
    pub fn fetch_metadata(&mut self, cube_url: String) {
        let resp = match fetch_cube_metadata(&cube_url) {
            Ok(resp) => resp,
            Err(err) => {
                eprintln!("{} {}", "Error: could not fetch cube metadata: ".red(), err);
                std::process::exit(0);
            }
        };

        self.cube_count = resp.cubes.len();
        self.metadata = Some(resp);
    }

    pub fn generate(&self, output_dir: String, file_name: String, _skip_errors: bool) {
        let config = match configuration::read() {
            Ok(c) => c,
            Err(e) => {
                eprintln!(
                    "{} {}",
                    "Error: Could not read the configuration file: ".red(),
                    e
                );
                return;
            }
        };

        let mut output = String::new();
        let mut all_dimension_types: Vec<String> = Vec::new();
        let mut all_measure_types: Vec<String> = Vec::new();
        let mut measure_count_types: Vec<String> = Vec::new();

        let file_header =
            "// !! This file is generated by Cube Type Extractor RS - do not modify !!";
        _ = output.push_str(file_header);
        _ = output.push('\n');

        let metadata = match &self.metadata {
            Some(m) => m,
            None => {
                eprintln!("{}", "Error: Metadata is missing".red());
                return;
            }
        };

        let pb = ProgressBar::new(metadata.cubes.len() as u64);

        pb.set_style(
            ProgressStyle::default_bar()
                .template("{msg} [{bar:40.yellow}] {pos}/{len} {eta}")
                .unwrap()
                .progress_chars("▇▆▅▄▃▂ "),
        );

        for cube in &metadata.cubes {
            // skip a cube that contains the word Error
            if cube.name.contains("Error") {
                pb.set_message(format!("Skipping cube: {}", cube.name));
                continue;
            }

            pb.set_message(format!("Processing cube: {}", cube.name));

            if let Some(union) = process_cube(cube) {
                for prefix in &config.prefixes {
                    if prefix.name == cube.name {
                        let dimension_type_name = format!("{}Dimensions", prefix.prefix);
                        let measure_type_name = format!("{}Measures", prefix.prefix);

                        _ = output.push('\n');
                        _ = output.push_str(&format!(
                            "export type {} = {}",
                            dimension_type_name, union.dimensions
                        ));

                        _ = output.push('\n');
                        _ = output.push_str(&format!(
                            "export type {} = {}",
                            measure_type_name, union.measures
                        ));
                        _ = output.push('\n');

                        all_dimension_types
                            .extend(dimension_type_name.split(" | ").map(String::from));
                        all_measure_types.extend(measure_type_name.split(" | ").map(String::from));

                        if config.enable_count_types {
                            let measure_counts = format!("{}CountMeasures", prefix.prefix);

                            for measure in union.measures.split(" | ") {
                                if measure.ends_with("Count'") {
                                    measure_count_types.push(measure.to_string());
                                }
                            }

                            if measure_count_types.is_empty() {
                                _ = output.push('\n');
                                _ = output.push_str(&format!(
                                    "export type {} = {}",
                                    measure_counts,
                                    measure_count_types.join(" | ")
                                ));
                                _ = output.push('\n');
                            }
                        }

                        pb.inc(1);
                    }
                }
            } else {
                // handle the case where the union is empty though this shouldnt really happen
            }
        }

        _ = output.push('\n');
        _ = output.push_str(&format!(
            "// !! All dimensions and measures for all cubes !!\n"
        ));

        _ = output.push_str(&format!(
            "export type AllDimensions = {}",
            join_union_fields(all_dimension_types)
        ));
        _ = output.push('\n');

        _ = output.push_str(&format!(
            "export type AllMeasures = {}",
            join_union_fields(all_measure_types)
        ));
        _ = output.push('\n');
        _ = output.push('\n');
        _ = output.push_str(&format!("// !! All measures counts for all cubes !!\n"));

        if config.enable_count_types {
            if measure_count_types.is_empty() {
                _ = output.push_str(&format!(
                    "export type AllMeasureCounts = {}",
                    join_union_fields(measure_count_types)
                ));
                _ = output.push('\n');
            }
        }

        _ = write_to_file(&output_dir, &file_name, &output);

        pb.finish_with_message("Task complete");
    }
}

fn write_to_file(output_dir: &str, file_name: &str, output: &str) -> std::io::Result<()> {
    let file_path = std::path::PathBuf::from(output_dir).join(format!("{}.ts", file_name));
    let path = std::path::Path::new(&file_path);

    if path.exists() {
        std::fs::remove_file(path)?;
    }

    let mut file = std::fs::File::create(path)?;
    std::io::Write::write_all(&mut file, output.as_bytes())?;

    Ok(())
}

#[derive(Debug)]
struct CubeUnion {
    dimensions: String,
    measures: String,
}

fn process_cube(cube: &Cube) -> Option<CubeUnion> {
    let dimensions = match &cube.dimensions {
        Some(d) => d,
        None => {
            eprintln!("{}", "Error: No dimensions are defined".red());
            return None;
        }
    };

    let measures = match &cube.measures {
        Some(m) => m,
        None => {
            eprintln!("{}", "Error: No measures are defined".red());
            return None;
        }
    };

    let dimension_union = extract_to_union(dimensions);
    let measure_union = extract_to_union(measures);

    Some(CubeUnion {
        dimensions: dimension_union,
        measures: measure_union,
    })
}

fn extract_to_union(fields: &[FieldSet]) -> String {
    let items = fields
        .iter()
        .filter_map(|field| {
            field
                .meta
                .as_ref()
                .and_then(|meta| meta.extractable)
                .filter(|&extractable| extractable)
                .map(|_| format!("'{}'", extract_name(&field.name)))
        })
        .collect::<HashSet<_>>(); // Avoid duplicate field names

    items.into_iter().collect::<Vec<_>>().join(" | ")
}

#[tokio::main]
async fn fetch_cube_metadata(cube_url: &str) -> Result<Metadata, Box<dyn std::error::Error>> {
    let client = reqwest::Client::new();
    let url = format!("{}/v1/meta", cube_url);

    let body = client
        .get(&url)
        .send()
        .await?
        .error_for_status()? // check for http errors
        .text()
        .await?;

    let metadata: Metadata = serde_json::from_str(&body).map_err(|e| {
        eprintln!("Error decoding response: {}", e);
        e
    })?;

    Ok(metadata)
}

fn extract_name(full_name: &str) -> Cow<str> {
    full_name
        .rsplit_once('.')
        .map(|(_, name)| Cow::Borrowed(name))
        .unwrap_or(Cow::Borrowed(full_name))
}

fn join_union_fields<I>(items: I) -> String
where
    I: IntoIterator<Item = String>,
{
    let unique: HashSet<_> = items.into_iter().collect();
    unique.into_iter().collect::<Vec<_>>().join(" | ")
}
